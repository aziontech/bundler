import fs from 'fs';
import path from 'path';
import mime from 'mime-types';
import { copyDirectory, feedback } from '#utils';

/**
 * normalize directory path
 * @param {string} dir
 * @returns {string}
 */
function normalizeDirPath(dir) {
  const pathNormalize = path.normalize(dir);
  return pathNormalize.startsWith('/') ? pathNormalize : `/${pathNormalize}`;
}

/**
 * is trace file
 * @param {string} pathFile
 * @returns {boolean}
 */
function isTraceFile(pathFile) {
  if (/\b\w+\.nft\.json\b/.test(pathFile) || /\/\.next\/trace/.test(pathFile)) {
    return true;
  }
  return false;
}

/**
 * Read the directories
 * @param {string} rootDir - main folder where to get the directories. e.g ./
 * @param {string[]} result - result to path files
 * @param {string} dir - current directory
 * @param {string[]} excludeDirs - exclude directories. e.g [".next/cache"]
 */
function readDir(rootDir, result, dir, excludeDirs) {
  const entries = fs.readdirSync(path.resolve(rootDir, dir), {
    withFileTypes: true,
  });
  for (const entry of entries) {
    const name = path.resolve(rootDir, dir, entry.name);
    const isDirectory = entry.isDirectory();
    if (isDirectory && !excludeDirs.some((exDir) => path.resolve(rootDir, exDir).startsWith(name))) {
      readDir(rootDir, result, name, excludeDirs);
    } else if (!isDirectory) {
      // removing trace files
      if (isTraceFile(name)) {
        continue;
      }
      result.push(normalizeDirPath(path.relative(rootDir, name)));
    }
  }
}

/**
 * Test module
 * @param {string} path - path file
 * @returns
 */
function moduleTest(path) {
  if (path.endsWith('/next.config.js') || path.endsWith('/next.config.mjs')) {
    return true;
  }
  return path.indexOf('/.next/server/') !== -1 && !path.endsWith('.html') && !path.endsWith('.map') && !path.endsWith('.json');
}

/**
 * Class build static Custom Server Next.js
 * @example
 *
 *   const buildStatic = new BuildStatic({
 *      rootDir: "../",
 *      includeDirs: ["./.next", "./public"],
 *      staticDirs: ["public", ".next/static"],
 *      excludeDirs: ["./.next/cache"],
 *      out: "tmp-next-build",
 *      versionId: "20230828181018",
 *      staticOutDir: ".edge/storage"
 *   });
 *
 *   buildStatic.run();
 *
 */
class BuildStatic {
  /**
   * Create a Dispatcher.
   * @param {object} config - The config build static.
   * @param {string} config.rootDir - main folder where to get the directories. e.g ./
   * @param {string[]} config.includeDirs - directories for the build. e.g [".next"]
   * @param {string[]} config.staticDirs - static directories. e.g [".next", "/public"]
   * @param {string[]} config.excludeDirs - exclude directories. e.g [".next/cache"]
   * @param {string} config.out - directory where the file will be generated
   * @param {string} config.versionId - versionId static storage e.g 20230828181018
   * @param {string} config.staticOutDir - folder where statics are sent for upload default (.edge/storage)
   */
  constructor(config) {
    this.config = config;
    this.config.staticOutDir = this.config.staticOutDir || '.edge/storage';
  }

  run = () => {
    if (this.config?.includeDirs?.length === 0) {
      throw new Error('please include at least one directory');
    }

    fs.mkdirSync(path.resolve(this.config.rootDir, this.config.out), {
      recursive: true,
    });

    let includedFiles = [];
    this.config.includeDirs.map((dir) => readDir(this.config.rootDir, includedFiles, dir, this.config.excludeDirs));
    const staticFiles = includedFiles.filter((file) => this.config.staticDirs.some((stDirs) => file.startsWith(normalizeDirPath(stDirs))));
    const serverFiles = includedFiles.filter((file) => !this.config.staticDirs.some((stDirs) => file.startsWith(normalizeDirPath(stDirs))));

    let assets = '';
    let fileContent = `
    /* 
     * Generated by Vulcan.
     */
   \n`;

    const totalFilterFiles = serverFiles.length + staticFiles.length;
    feedback.prebuild.interactive.await(`[%d/${totalFilterFiles}] - build config and static files`, 1);
    let countProcessFile = 0;

    // import server module files
    for (const [index, file] of serverFiles.entries()) {
      const moduleTestValue = moduleTest(file);
      const pathFile = path.resolve(this.config.rootDir, `.${file}`);
      const contentType = mime.lookup(pathFile);
      if (moduleTestValue) {
        const relativeFilePath = path.relative(this.config.out, `.${file}`);
        fileContent += `import * as fileModule${index} from "${relativeFilePath}";\n`;
        assets += `${JSON.stringify(file)}: { contentType: "${contentType}", content: "", isStatic: false, module: fileModule${index} },\n`;
      } else {
        const arrayBuffer = fs.readFileSync(pathFile);
        const bufferObject = JSON.stringify(arrayBuffer.toString('base64'));
        assets += `${JSON.stringify(file)}: { contentType: "${contentType}", content: ${bufferObject}, isStatic: false, module: null },\n`;
      }
      countProcessFile += 1;
      feedback.prebuild.interactive.await(`[%d/${totalFilterFiles}] - ${file}`, countProcessFile);
    }

    // create statics content
    fileContent += `\nexport const assets = {\n`;
    for (const [index, file] of staticFiles.entries()) {
      const pathFile = path.resolve(this.config.rootDir, `.${file}`);
      const contentType = mime.lookup(pathFile);
      assets += `${JSON.stringify(file)}: { contentType: "${contentType}", content: ${JSON.stringify(
        `${this.config.versionId}${file}`
      )}, isStatic: true, module: null },\n`;
      countProcessFile += 1;
      feedback.prebuild.interactive.await(`[%d/${totalFilterFiles}] - ${file}`, countProcessFile);
    }

    fileContent += assets;

    fileContent += '};\n';

    fs.writeFileSync(path.resolve(this.config.rootDir, this.config.out, 'statics.js'), fileContent);

    for (let i = 0; i < this.config.staticDirs.length; i++) {
      const dir = this.config.staticDirs[i];
      copyDirectory(path.resolve(this.config.rootDir, dir), path.resolve(this.config.rootDir, this.config.staticOutDir, dir));
    }

    feedback.prebuild.success(`[${countProcessFile}] - The total number of files processed!`);
  };
}

export default BuildStatic;
