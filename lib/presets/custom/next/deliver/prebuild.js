import { readdir, stat, mkdir, rm, copyFile } from 'fs/promises';
import { join, extname, basename, dirname } from 'path';
import { gte, coerce, valid } from 'semver';

import {
  exec,
  feedback,
  getPackageManager,
  getPackageVersion,
  copyDirectory,
  generateManifest,
} from '#utils';
import { getNextConfig, readManifestFile } from '../utils.next.js';

const packageManager = await getPackageManager();

const cdnManifest = {
  rules: {
    request: [
      {
        match: '^\\/',
        setOrigin: {
          type: 'object_storage',
        },
      },
      {
        match: '.*/$',
        // eslint-disable-next-line no-template-curly-in-string
        rewrite: {
          set: (uri) => `${uri}index.html`,
        },
      },
      {
        match: '^(?!.*/$)(?![sS]*.[a-zA-Z0-9]+$).*',
        // eslint-disable-next-line no-template-curly-in-string
        rewrite: {
          set: (uri) => `${uri}index.html`,
        },
      },
    ],
  },
};

/**
 * Moves HTML and corresponding TXT files to subdirectories and
 * renames the HTML files to 'index.html'.
 * This function is used to organize the static files generated by Next.js during the build process.
 * It looks for HTML files in the specified directory and its subdirectories.
 * When it finds an HTML file,
 * it creates a new subdirectory with the same name as the HTML file (without the .html extension),
 * and moves the HTML file to that subdirectory, renaming it to 'index.html'.
 * If there is a corresponding TXT file with the same base name (before .html extension),
 * it will also be moved
 * to the same subdirectory with its original name.
 * @param {string} directory - The root directory to start moving files.
 * @example
 * // Before:
 * // Root directory: '/path/to/project/.edge/storage'
 * // Files in the directory: ['home.html', 'about.html', 'contact.html', 'styles.css']
 *
 * // After calling moveFiles('/path/to/project/.edge/storage'):
 * // Root directory: '/path/to/project/.edge/storage'
 * // Files in the directory: ['styles.css']
 * // Subdirectory 'home':
 * //   - index.html (previously home.html)
 * //   - home.txt
 * // Subdirectory 'about':
 * //   - index.html (previously about.html)
 * //   - about.txt
 * // Subdirectory 'contact':
 * //   - index.html (previously contact.html)
 * //   - contact.txt
 */
async function moveFiles(directory) {
  const files = await readdir(directory);

  await Promise.all(
    files.map(async (file) => {
      const filePath = join(directory, file);
      const fileStat = await stat(filePath);

      if (fileStat.isDirectory()) {
        await moveFiles(filePath); // Recursive call for subdirectories
      } else if (
        extname(file) === '.html' &&
        file !== 'index.html' &&
        file !== '404.html'
      ) {
        const newDirectoryName = basename(file, '.html');
        const newDirectoryPath = join(directory, newDirectoryName);

        await mkdir(newDirectoryPath, { recursive: true });

        const newHTMLPath = join(newDirectoryPath, 'index.html');
        await copyFile(filePath, newHTMLPath);

        feedback.prebuild.info(`Moved ${filePath} to ${newHTMLPath}`);

        const correspondingTXTFile = `${basename(file, '.html')}.txt`;
        const correspondingTXTPath = join(directory, correspondingTXTFile);

        if (files.includes(correspondingTXTFile)) {
          const newTXTParentDirectory = dirname(newHTMLPath);
          const newTXTPath = join(newTXTParentDirectory, correspondingTXTFile);
          await copyFile(correspondingTXTPath, newTXTPath);
          feedback.prebuild.info(
            `Moved ${correspondingTXTPath} to ${newTXTPath}`,
          );
        }
      }
    }),
  );
}

/**
 * Fix Nextjs routing problems using a default storage
 */
async function fixAppDirRoutes() {
  const getRouteDirPath = (path) => {
    const pathSegments = path.split('/');
    pathSegments.pop();

    return pathSegments.join('/');
  };

  const routesManifest = await readManifestFile('routes-manifest.json');
  const dynamicRoutes = routesManifest.dynamicRoutes.map((route) => route.page);

  let appPathRoutesManifest;
  try {
    appPathRoutesManifest = await readManifestFile(
      'app-path-routes-manifest.json',
    );
  } catch (error) {
    feedback.prebuild.info('app dir use not detected in project.');
    return;
  }

  const appPagesPaths = Object.keys(appPathRoutesManifest)
    .filter((pathKey) => pathKey.match(/page/))
    .map((key) => appPathRoutesManifest[key]);

  const pathsToCopy = appPagesPaths.filter(
    (path) => !dynamicRoutes.includes(path) && path !== '/',
  );

  // fix _next calls in client (static routes in app dir format)
  pathsToCopy.forEach(async (path) => {
    const storagePath = '.edge/storage';
    const filesToCopy = [`${path}.html`, `${path}.txt`];

    const dirPath = getRouteDirPath(path);
    await mkdir(join(process.cwd(), storagePath, '_next', dirPath), {
      recursive: true,
    });

    filesToCopy.forEach(async (file) => {
      const src = join(process.cwd(), storagePath, file);
      const dest = join(process.cwd(), storagePath, '_next', file);
      await copyFile(src, dest);
    });
  });
}

/**
 * Detect if version is >= 13.3.0
 * In this version the static site had significant changes in how to use and how to build.
 * doc reference:
 * https://nextjs.org/docs/pages/building-your-application/deploying/static-exports
 * https://nextjs.org/docs/app/building-your-application/deploying/static-exports
 * @param {string} version - Next.js version ("latest" or in "x.x.x" format).
 * @returns {boolean} - a boolean indicating if is a recent version or not.
 * @example
 * isANewerVersion('^14.2.3') returns true.
 * isANewerVersion('~13.0.0') returns false.
 * isANewerVersion('*') returns true.
 * isANewerVersion('>returns13.3.0<14.0.0') returns true.
 * isANewerVersion('13.x') returns false.
 * isANewerVersion('>=12.0<13') returns false.
 * isANewerVersion('13.4') returns true.
 * isANewerVersion('latest') returns true.
 * isANewerVersion('x') returns true.
 * isANewerVersion('11') returns false.
 */
function isANewerVersion(version) {
  if (['latest', '*', 'x', 'X'].includes(version)) {
    return true;
  }

  const targetVersion = '13.3.0';
  // use semver to check if is a greater or equal version
  if (gte(valid(coerce(version)), targetVersion)) {
    return true;
  }

  return false;
}

/**
 * Validates if static site mode is enabled in next config.
 * @param {object} nextConfig - the config as JSON object.
 */
function validateStaticSiteMode(nextConfig) {
  if (!nextConfig || !nextConfig.output || nextConfig.output !== 'export') {
    const errorMessage = `Static site mode not enabled in project config.
    You must add 'output: "export"' in your 'next.config.js' or 'next.config.mjs' file if you are trying to build a Next.js v >= 13.3 static project.
    For more details go to https://nextjs.org/docs/pages/building-your-application/deploying/static-exports or https://nextjs.org/docs/app/building-your-application/deploying/static-exports \n`;
    throw Error(errorMessage);
  }
}

/**
 * Runs custom prebuild actions
 */
async function prebuild() {
  feedback.prebuild.info('Starting Next.js static build process...');

  const nextVersion = getPackageVersion('next');
  feedback.prebuild.info('Detected Next.js version:', nextVersion);

  const staticsOutputDir = '.edge/storage';

  // new build format
  if (isANewerVersion(nextVersion)) {
    const nextConfig = await getNextConfig();

    validateStaticSiteMode(nextConfig);

    // check if an output path is specified in config file
    let outDir = 'out';

    if (nextConfig.distDir) {
      outDir = nextConfig.distDir;
    }

    await exec(`${packageManager} run build`, `Next ${nextVersion}`, true);

    // move files to vulcan default path
    copyDirectory(outDir, staticsOutputDir);
    rm(outDir, { recursive: true, force: true });

    feedback.prebuild.info('Adapting Next.js build output...');
    await moveFiles(`${process.cwd()}/${staticsOutputDir}`);
    await fixAppDirRoutes();
  } else {
    // old build format

    await exec(`${packageManager} run build`, `Next ${nextVersion}`, true);

    await exec(
      `npx next export -o ${staticsOutputDir}`,
      `Next ${nextVersion}`,
      true,
    );

    feedback.prebuild.info('Adapting Next.js build output...');
    await moveFiles(`${process.cwd()}/${staticsOutputDir}`);
  }

  await generateManifest(cdnManifest);

  feedback.prebuild.success('Next.js build adaptation completed successfully.');
}

export default prebuild;
