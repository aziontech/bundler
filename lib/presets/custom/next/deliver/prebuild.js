import { gte, coerce, valid } from 'semver';
import {
  exec, feedback, getPackageManager, getPackageVersion, copyDirectory,
} from '#utils';

import {
  readdir, stat, rename, mkdir, readFile, rm,
} from 'fs/promises';
import {
  join, extname, basename, dirname,
} from 'path';

const packageManager = await getPackageManager();

/**
 * Moves HTML and corresponding TXT files to subdirectories and
 * renames the HTML files to 'index.html'.
 * This function is used to organize the static files generated by Next.js during the build process.
 * It looks for HTML files in the specified directory and its subdirectories.
 * When it finds an HTML file,
 * it creates a new subdirectory with the same name as the HTML file (without the .html extension),
 * and moves the HTML file to that subdirectory, renaming it to 'index.html'.
 * If there is a corresponding TXT file with the same base name (before .html extension),
 * it will also be moved
 * to the same subdirectory with its original name.
 * @param {string} directory - The root directory to start moving files.
 * @example
 * // Before:
 * // Root directory: '/path/to/project/.edge/storage'
 * // Files in the directory: ['home.html', 'about.html', 'contact.html', 'styles.css']
 *
 * // After calling moveFiles('/path/to/project/.edge/storage'):
 * // Root directory: '/path/to/project/.edge/storage'
 * // Files in the directory: ['styles.css']
 * // Subdirectory 'home':
 * //   - index.html (previously home.html)
 * //   - home.txt
 * // Subdirectory 'about':
 * //   - index.html (previously about.html)
 * //   - about.txt
 * // Subdirectory 'contact':
 * //   - index.html (previously contact.html)
 * //   - contact.txt
 */
async function moveFiles(directory) {
  const files = await readdir(directory);

  await Promise.all(
    files.map(async (file) => {
      const filePath = join(directory, file);
      const fileStat = await stat(filePath);

      if (fileStat.isDirectory()) {
        await moveFiles(filePath); // Recursive call for subdirectories
      } else if (
        extname(file) === '.html'
        && file !== 'index.html'
        && file !== '404.html'
      ) {
        const newDirectoryName = basename(file, '.html');
        const newDirectoryPath = join(directory, newDirectoryName);

        await mkdir(newDirectoryPath, { recursive: true });

        const newHTMLPath = join(newDirectoryPath, 'index.html');
        await rename(filePath, newHTMLPath);
        feedback.prebuild.info(`Moved ${filePath} to ${newHTMLPath}`);

        const correspondingTXTFile = `${basename(file, '.html')}.txt`;
        const correspondingTXTPath = join(directory, correspondingTXTFile);

        if (files.includes(correspondingTXTFile)) {
          const newTXTParentDirectory = dirname(newHTMLPath);
          const newTXTPath = join(newTXTParentDirectory, correspondingTXTFile);
          await rename(correspondingTXTPath, newTXTPath);
          feedback.prebuild.info(`Moved ${correspondingTXTPath} to ${newTXTPath}`);
        }
      }
    }),
  );
}

/**
 * Detect if version is >= 13.3.0
 * In this version the static site had significant changes in how to use and how to build.
 * doc reference:
 * https://nextjs.org/docs/pages/building-your-application/deploying/static-exports
 * @param {string} version - Next.js version ("latest" or in "x.x.x" format).
 * @returns {boolean} - a boolean indicating if is a recent version or not.
 * @example
 * isANewerVersion('^14.2.3') returns true.
 * isANewerVersion('~13.0.0') returns false.
 * isANewerVersion('*') returns true.
 * isANewerVersion('>returns13.3.0<14.0.0') returns true.
 * isANewerVersion('13.x') returns false.
 * isANewerVersion('>=12.0<13') returns false.
 * isANewerVersion('13.4') returns true.
 * isANewerVersion('latest') returns true.
 * isANewerVersion('x') returns true.
 * isANewerVersion('11') returns false.
 */
function isANewerVersion(version) {
  if (['latest', '*', 'x', 'X'].includes(version)) {
    return true;
  }

  const targetVersion = '13.3.0';
  // use semver to check if is a greater or equal version
  if (gte(valid(coerce(version)), targetVersion)) {
    return true;
  }

  return false;
}

/**
 * Get next config file
 * @returns {object} - next config as a JSON
 */
async function getNextConfig() {
  try {
    const configPath = join(process.cwd(), 'next.config.js');
    const configModule = await import(configPath);

    return configModule.default;
  } catch (error) {
    throw Error('Error reading next config file:', error);
  }
}

/**
 * Validates if static site mode is enabled in next config.
 * @param {object} nextConfig - the config as JSON object.
 */
function validateStaticSiteMode(nextConfig) {
  if (!nextConfig.output || nextConfig.output !== 'export') {
    throw Error('Static site mode not enabled in config!');
  }
}

/**
 * Runs custom prebuild actions
 * @param {object} buildContext - info about the build
 */
async function prebuild(buildContext) {
  try {
    feedback.prebuild.info('Starting Next.js static build process...');

    const nextVersion = getPackageVersion('next');
    feedback.prebuild.info('Detected Next.js version:', nextVersion);

    const staticsOutputDir = '.edge/storage';

    if (isANewerVersion(nextVersion)) {
      const nextConfig = await getNextConfig();

      validateStaticSiteMode(nextConfig);

      // check if an output path is specified in config file
      let outDir = 'out';
      const configFileContent = await readFile('./next.config.js', 'utf-8');
      const attributeMatch = Array.from(
        configFileContent.matchAll(/distDir:(.*),/g),
        (match) => match,
      )[0];
      if (attributeMatch) {
        // get the specified value in config
        outDir = attributeMatch[1].trim().replace(/["']/g, '');
      }

      await exec(`${packageManager} run build`, `Next ${nextVersion}`, true);

      // move files to vulcan default path
      copyDirectory(outDir, staticsOutputDir);
      rm(outDir, { recursive: true, force: true });

      feedback.prebuild.info('Adapting Next.js build output...');
      await moveFiles(`${process.cwd()}/${staticsOutputDir}`);
    } else {
      await exec(`${packageManager} run build`, `Next ${nextVersion}`, true);

      await exec(`npx next export -o ${staticsOutputDir}`, `Next ${nextVersion}`, true);

      feedback.prebuild.info('Adapting Next.js build output...');
      await moveFiles(`${process.cwd()}/${staticsOutputDir}`);
    }

    feedback.prebuild.success('Next.js build adaptation completed successfully.');
  } catch (error) {
    feedback.prebuild.error('Error occurred during Next.js build adaptation:', error);
  }
}

export default prebuild;
